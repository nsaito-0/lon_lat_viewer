<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lat/Lon tooltip</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 16px; }
    .wrap { position: relative; display: inline-block; }

    /* 画像 */
    #mapImg { display: block; max-width: 100%; height: auto; }

    /* ツールチップ */
    #tip {
      position: absolute;
      pointer-events: none;
      background: rgba(0,0,0,0.75);
      color: #fff;
      padding: 6px 8px;
      border-radius: 6px;
      font-size: 12px;
      line-height: 1.25;
      white-space: nowrap;
      transform: translate(10px, 10px);
      display: none;
      z-index: 10;
    }

    /* （任意）データ領域を可視化したいときの枠 */
    /* #dataBox { position:absolute; border:1px dashed red; pointer-events:none; } */
  </style>
</head>
<body>

<h3>画像上で緯度経度を表示（度＋分）</h3>

<div class="wrap" id="wrap">
  <img id="mapImg" src="frame_00002.png" alt="map image" />
  <div id="tip"></div>
  <!-- <div id="dataBox"></div> -->
</div>

<script>
/**
 * ====== 設定ここだけ変更 ======
 * extent: [lon_min, lon_max, lat_min, lat_max]  (PlateCarree)
 */
const extent = {
  lonMin: 136.6,
  lonMax: 137.5,
  latMin: 36.7,
  latMax: 37.62,
};

/**
 * dataRect:
 * 画像ファイル内の「地図データ領域」ピクセル範囲（左上原点）。
 * もし“地図領域だけのPNG”なら、全域を指定すればOK。
 *
 * 例：
 *  - 地図領域だけのPNG → left=0, top=0, width=imgW, height=imgH
 *  - カラーバー/余白込みPNG → 地図領域だけの矩形を指定
 */
const dataRect = {
  left: 60,   // px
  top:  57,   // px
  width: 760,   // null のときは画像実寸に合わせる
  height: 374,  // null のときは画像実寸に合わせる
};

/** ====== ここから下は基本触らない ====== */

const img = document.getElementById("mapImg");
const tip = document.getElementById("tip");
// const dataBox = document.getElementById("dataBox");

function degMin(decDeg, isLat) {
  const hemi = isLat ? (decDeg >= 0 ? "N" : "S") : (decDeg >= 0 ? "E" : "W");
  const abs = Math.abs(decDeg);
  const deg = Math.floor(abs);
  const min = (abs - deg) * 60.0;
  // 分は小数表示（例：12.34'）
  return `${deg}° ${min.toFixed(2)}' ${hemi}`;
}

function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }

function updateDataRectFromImage() {
  // 画像の実寸（natural）に合わせて dataRect の width/height を埋める
  if (dataRect.width === null) dataRect.width = img.naturalWidth - dataRect.left;
  if (dataRect.height === null) dataRect.height = img.naturalHeight - dataRect.top;

  // データ領域可視化（任意）
  // dataBox.style.left = `${dataRect.left}px`;
  // dataBox.style.top = `${dataRect.top}px`;
  // dataBox.style.width = `${dataRect.width}px`;
  // dataBox.style.height = `${dataRect.height}px`;
}

// 画像ロード後に初期化
img.addEventListener("load", () => {
  updateDataRectFromImage();
});

img.addEventListener("mousemove", (ev) => {
  const rect = img.getBoundingClientRect();

  // 表示上の座標（CSSピクセル）
  const xCss = ev.clientX - rect.left;
  const yCss = ev.clientY - rect.top;

  // 画像の実寸（natural pixel）へ変換
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const xNat = xCss * scaleX;
  const yNat = yCss * scaleY;

  // データ領域内か判定
  const xIn = xNat - dataRect.left;
  const yIn = yNat - dataRect.top;

  if (xIn < 0 || yIn < 0 || xIn > dataRect.width || yIn > dataRect.height) {
    tip.style.display = "none";
    return;
  }

  // 0..1（左→右、上→下）
  const u = clamp(xIn / dataRect.width, 0, 1);
  const v = clamp(yIn / dataRect.height, 0, 1);

  // PlateCarree なので線形変換
  const lon = extent.lonMin + u * (extent.lonMax - extent.lonMin);

  // 注意：画像のyは上が0なので、緯度は上ほど latMax
  const lat = extent.latMax - v * (extent.latMax - extent.latMin);

  // 表示
  tip.style.display = "block";
  tip.style.left = `${xCss}px`;
  tip.style.top = `${yCss}px`;
  tip.textContent = `Lat: ${degMin(lat, true)}\nLon: ${degMin(lon, false)}`;
});

img.addEventListener("mouseleave", () => {
  tip.style.display = "none";
});
</script>

</body>
</html>
